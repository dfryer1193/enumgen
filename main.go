package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/dfryer1193/enumgen/generator/domain"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names; must be set")
	output    = flag.String("output", "", "output file name; default srcdir/<type>_enum.go")
)

func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of enumgen:\n")
	fmt.Fprintf(os.Stderr, "\tenumgen [flags] -type T [directory]\n")
	flag.PrintDefaults()
}

func main() {
	flag.Usage = Usage
	flag.Parse()
	if len(flag.Args()) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	types := strings.Split(*typeNames, ",")

	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}

	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}

	pkgs := loadPackages(args)
	sort.Slice(pkgs, func(i, j int) bool {
		iTest := strings.HasSuffix(pkgs[i].name, "_test")
		jTest := strings.HasSuffix(pkgs[j].name, "_test")
		if iTest && jTest {
			return !iTest
		}

		return len(pkgs[i].files) < len(pkgs[j].files)
	})
	{
		_, err := os.Getwd()
		if err != nil {
			log.Fatal(err)
		}

		files, err := filepath.Glob("*.go")
		if err != nil {
			log.Fatal(err)
		}

		fs := token.NewFileSet()
		var pkgName string
		var enumConsts []domain.EnumConst

		for _, file := range files {
			node, err := parser.ParseFile(fs, file, nil, parser.AllErrors)
			if err != nil {
				log.Fatalf("Failed to parse %s: %v", file, err)
			}
			if pkgName == "" {
				pkgName = node.Name.Name
			}

			for _, decl := range node.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.CONST {
					continue
				}
				for _, spec := range genDecl.Specs {
					valSpec, ok := spec.(*ast.ValueSpec)
					if !ok {
						continue
					}

					var typeName string
					if valSpec.Type != nil {
						if ident, ok := valSpec.Type.(*ast.Ident); ok {
							typeName = ident.Name
						}
					}
					if typeName != *enumType {
						continue
					}

					for i, name := range valSpec.Names {
						if len(valSpec.Values) <= i {
							continue
						}
						basicLit, ok := valSpec.Values[i].(*ast.BasicLit)
						if !ok || basicLit.Kind.String() != "STRING" {
							continue
						}
						val := strings.Trim(basicLit.Value, `"`)
						enumConsts = append(enumConsts, EnumConst{
							Name:  name.Name,
							Value: val,
						})
					}
				}
			}
		}

		if len(enumConsts) == 0 {
			log.Fatalf("No constants of type %s found", *enumType)
		}

		outputFile := fmt.Sprintf("%s_enumvalidator_gen.go", strings.ToLower(*enumType))
		out, err := os.Create(outputFile)
		if err != nil {
			log.Fatal(err)
		}
		defer out.Close()

		err = validatorTemplate.Execute(out, map[string]interface{}{
			"Package":   pkgName,
			"Type":      *enumType,
			"TypeLower": strings.ToLower(*enumType),
			"ConstList": enumConsts,
		})
		if err != nil {
			log.Fatal(err)
		}

		fmt.Printf("Generated: %s\n", outputFile)
	}
}

func baseName(pkg *domain.Package, typename string) string {
	suffix := "enum.go"
	if pkg.hasTestFiles {
		suffix = "enum_test.go"
	}

	return fmt.Sprintf("%s_%s", strings.ToLower(typename), suffix)
}

var validatorTemplate = template.Must(template.New("validator").Parse(`// Code generated by enumgen; DO NOT EDIT.

package {{ .Package }}

import "fmt"

var {{ .TypeLower }}Values = map[string]{{ .Type }}{
{{- range .ConstList }}
	"{{ .Value }}": {{ .Name }},
{{- end }}
}

func Validate{{ .Type }}(value string) ({{ .Type }}, error) {
	v, ok := {{ .TypeLower }}Values[value]
	if !ok {
		return "", fmt.Errorf("invalid {{ .Type }}: %q", value)
	}
	return v, nil
}
`))
